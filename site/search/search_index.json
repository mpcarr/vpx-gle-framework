{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to VPX Game Logic Framework","text":"<p>This project is a framework for making original virtual pinball tables using the VPX platform. It is based on The Mission Pinball Framework for real and homebrew machines. Many of the game logic commands mirror the MPF commands as one of the goals of this project is to have an interchangeable config between vpx and mpf. Another goal of this project is to have a standalone set of game logic devices that doesn't not require the end user to install and run the mpf bridge for vpx.</p>"},{"location":"#installation","title":"Installation","text":"<p>Check out the Installing GLF Guide to get started.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#game-logic-devices","title":"Game Logic Devices","text":"<p>A well designed Virtual Pinball table contains many of the real world devices such as scoops, vuks (vertical up kickers), plungers, diverters, drop targets e.t.c. These devices are machine wide devices that need to respond to the ball interacting with them. The classes found in the framework mimic these device behaviours by monitoring and dispatching events which other parts of the system can respond to.</p> <ul> <li>Ball Device</li> <li>Diverters</li> <li>Drop Targets</li> </ul>"},{"location":"#game-logic-commands","title":"Game Logic Commands","text":"<p>To program your game, the framework provides a set of classes to manage the game life-cycle, player state, player score, modes, timers, light shows and manage your DMD or LCD game display.</p> <ul> <li>Ball Save</li> <li>Counter</li> <li>Event Player</li> <li>Light Player</li> <li>Mode</li> <li>Multball Locks</li> <li>Multiball</li> <li>Show Player</li> <li>Timer</li> </ul>"},{"location":"#events-system","title":"Events System","text":""},{"location":"#player-state","title":"Player State","text":""},{"location":"ball-device/","title":"Ball Device","text":"<p>A ball device is anything on your table that can hold a ball and then release it.</p>"},{"location":"ball-device/#scoop-example","title":"Scoop Example","text":"<pre><code>Dim ball_device_scoop\nSet ball_device_scoop = (new BallDevice)(\"scoop\")\n\nWith ball_device_scoop\n    .BallSwitches = Array(\"sw39\")\n    .EjectTimeout = 2\n    .EjectCallback = \"ScoopKickBall\"\n    .EjectAllEvents = Array(\"ball_ended\")\nEnd With\n</code></pre> <p>In the above example we created a ball device called ball_device_scoop, it has one switch so holds one ball and an eject timeout of 2 seconds. When the ball ends, if there are any balls in this device, it will eject them as we set the eject all events to ball_ended.</p>"},{"location":"ball-device/#plunger-example","title":"Plunger Example","text":"<pre><code>Dim ball_device_scoop\nSet ball_device_scoop = (new BallDevice)(\"plunger\")\n\nWith ball_device_scoop\n    .BallSwitches = Array(\"sw10\")\n    .EjectTimeout = 2\n    .EjectCallback = \"AutoPlunge\"\n    .MechcanicalEject = True\n    .DefaultDevice = True\nEnd With\n</code></pre> <p>In the above example we created a plunger ball device, This plunger has a real plunger so we set the mechcanical eject to true and also set the default device property to true as this is the device that is fed from the trough. This device also has a auto plunge so we set a callback of AutoPlunge so that sub will be called when the ball is auto plunged.</p>"},{"location":"ball-device/#required-setings","title":"Required Setings","text":""},{"location":"ball-device/#name","title":"Name","text":"<p><code>String</code></p> <p>The name of this device. Events emitted from the device will be in the format name_ball_device</p>"},{"location":"ball-device/#ball-switches","title":"Ball Switches","text":"<p><code>Array</code></p> <p>This is an array of switch / trigger names used to monitor what balls are in the device.</p>"},{"location":"ball-device/#eject-timeout","title":"Eject Timeout","text":"<p><code>Number</code></p> <p>A value in seconds that the ball device will wait until it deems the ball has been ejected</p>"},{"location":"ball-device/#eject-callback","title":"Eject Callback","text":"<p><code>String</code></p> <p>The sub or function to call when the ball is ejected. The ball device doesn't actually do anything to the ball, this sub must kick the ball out of the device.</p>"},{"location":"ball-device/#optional-settings","title":"Optional Settings","text":""},{"location":"ball-device/#default-device","title":"Default Device","text":"<p><code>Boolean</code></p> <p>The default device is the plunger. Set this to True for the device that the trough ejects to.</p>"},{"location":"ball-device/#eject-all-events","title":"Eject All Events","text":"<p><code>Array</code></p> <p>A list of event names that will cause the ball device to eject all it's balls. e.g. ball_ended</p>"},{"location":"ball-device/#player-controlled-eject-events","title":"Player Controlled Eject Events","text":"<p><code>Array</code></p> <p>A list of event names that will cause the ball device to eject one ball.</p>"},{"location":"ball-device/#mechcanical-eject","title":"Mechcanical Eject","text":"<p><code>Boolean</code></p> <p>If this device doesn't have an eject callback. e.g. a plunger moves the ball.</p>"},{"location":"ball-save/","title":"Ball Save","text":"<p>A ball save prevents a drained ball from ending the player's turn. It automatically returns the ball to the playfield, giving the player another chance to continue their game.</p>"},{"location":"ball-save/#example","title":"Example","text":"<pre><code>Dim ball_save_base\nSet ball_save_base = (new BallSave)(\"base\", mode_base)\n\nWith ball_save_base\n    .EnableEvents = Array(\"mode_base_started\")\n    .TimerStartEvents = Array(\"ball_device_plunger_eject_success\")\n    .ActiveTime = 15\n    .HurryUpTime = 5\n    .GracePeriod = 3\n    .BallsToSave = -1\n    .AutoLaunch = True\nEnd With\n</code></pre> <p>In the above example we created a ball save called ball_save_base that belongs to the mode called mode_base. The ball save is enabled when the mode starts and the timer will start when the a ball is successfully ejected from the plunger device. A hurry up event will be emitted When the timer gets to 5 seconds remaining. The ball save has a grace period of 3 seconds which means it will stay enabled for 3 seconds after the timer has finished.</p>"},{"location":"ball-save/#required-setings","title":"Required Setings","text":""},{"location":"ball-save/#name","title":"Name","text":"<p><code>String</code></p> <p>The name of this device. Events emitted from the device will be in the format name_ball_save</p>"},{"location":"ball-save/#mode","title":"Mode","text":"<p><code>String</code></p> <p>This is the mode the ball save belongs to. </p>"},{"location":"ball-save/#active-time","title":"Active Time","text":"<p><code>Number</code></p>"},{"location":"ball-save/#hurry-up-time","title":"Hurry Up Time","text":"<p><code>Number</code></p>"},{"location":"ball-save/#grace-period","title":"Grace Period","text":"<p><code>Number</code></p>"},{"location":"ball-save/#balls-to-save","title":"Balls To Save","text":"<p><code>Number</code></p>"},{"location":"ball-save/#auto-launch","title":"Auto Launch","text":"<p><code>Boolean</code></p>"},{"location":"commands/","title":"Command Referencee","text":"<p>Bla </p>"},{"location":"commands/#ball-device","title":"Ball Device","text":""},{"location":"commands/#ball-save","title":"Ball Save","text":""},{"location":"commands/#counter","title":"Counter","text":""},{"location":"commands/#diverter","title":"Diverter","text":""},{"location":"commands/#drop-target","title":"Drop Target","text":""},{"location":"commands/#event-player","title":"Event Player","text":""},{"location":"commands/#light-player","title":"Light Player","text":""},{"location":"commands/#mode","title":"Mode","text":""},{"location":"commands/#multiball-locks","title":"Multiball Locks","text":""},{"location":"commands/#multiball","title":"Multiball","text":""},{"location":"commands/#show-player","title":"Show Player","text":""},{"location":"commands/#timer","title":"Timer","text":""},{"location":"counter/","title":"Counter","text":"<p>A simple counter to monitor things like the number of times a target for switch has been hit.</p>"},{"location":"counter/#example","title":"Example","text":"<pre><code>Dim counter_pop_hits\nSet counter_pop_hits = (new Counter)(\"pop_hits\", mode_super_pops)\n\nWith counter_pop_hits\n    .EnableEvents = Array(\"mode_super_pops_started\")\n    .CountEvents = Array(\"sw30_active\", \"sw31_active\", \"sw32_active\")\n    .CountCompleteValue = 20\n    .DisableOnComplete = True\n    .ResetOnComplete = True\n    .EventsWhenComplete = Arrry(\"super_pops_qualified\")\n    .PersistState = True\nEnd With\n</code></pre> <p>In the above example we created a counter called counter_pop_hits that belongs to the mode called mode_super_pops. The counter is enabled when the mode starts and will increase its count value whenever one of the three pop bumbers are hit (sw30,sw31,sw32). Once complete, the counter will disable and reset its count and emit the event super_pops_qualified. The Persist State property means the counter will not reset between balls.</p>"},{"location":"counter/#required-setings","title":"Required Setings","text":""},{"location":"counter/#name","title":"Name","text":"<p><code>String</code></p> <p>The name of this device. Events emitted from the device will be in the format name_counter</p>"},{"location":"counter/#mode","title":"Mode","text":"<p><code>String</code></p> <p>This is the mode the counter belongs to. </p>"},{"location":"diverter/","title":"Diverter","text":"<p>A diverter in vpx is typically implemented using two walls or pimitives switching the colliable property depending on if the diverter is active or not. This virutal device manages if the diverter should be active or not and fires the callback to move the diverter.</p>"},{"location":"diverter/#examples","title":"Examples","text":"<p>Example 1: A ramp diverter that enables when multiball locks are open and diverts the ball after the ramp entrace switch is hit</p> <pre><code>Dim diverter_ramp\nSet diverter_ramp = (new Diverter)(\"ramp\")\n\nWith diverter_ramp\n    .EnableEvents = Array(\"multiball_locks_open\")\n    .DisableEvents = Array(\"multiball_locks_closed\")\n    .ActivationTime = 2\n    .ActivateEvents = Array(\"sw23_active\")\n    .ActionCallback = \"RampDiverter\"\nEnd With\n</code></pre> <p>In the above example we have a diverter on a ramp, it is enabled when the multibal_locks_open event is emitted and disables when the multiball_locks_closed is emitted. Enabling the diverter does not mean it activates (moves), it means that it will start to listen for it's activate events. When the event s23_active (ramp entrance switch) is emitted, the diverter will call the action callback RampDiverter. After 2 seconds will will call the same callback again with a disabled param.</p> <pre><code>Sub RampDiverter(enabled)\n    If enabled = 1 Then\n        'Activate Diverter Logic\n    Else\n        'Deactivate Diverter Logic\n    End If\nEnd Sub\n</code></pre> <p>Example 2: A diverter that opens during a mode and stays open until a disable event is emitted.</p> <pre><code>Dim diverter_orbit : Set diverter_orbit = (new Diverter)(\"orbit\")\nWith diverter_orbit\n    .EnableEvents = Array(\"game_started\")\n    .DisableEvents = Array(\"game_ended)\n    .ActivateEvents = Array(\"mode_hurry_started\")\n    .DisableEvents = Array(\"mode_hurry_ended\")\n    .ActionCallback = \"OrbitDiverter\"\nEnd With\n</code></pre> <p>In the above example, the diverter is enabled at game start and disabled at game end, it listens for the mode_hurry_started event to activate and will stay activated unti the mode_hurry_ended event.</p>"},{"location":"diverter/#required-settings","title":"Required Settings","text":""},{"location":"diverter/#name","title":"Name","text":"<p><code>String</code></p> <p>The name for this diverter. Events emitted from the diverter will be in the format name_diverter</p>"},{"location":"diverter/#enable-events","title":"Enable Events","text":"<p><code>Array</code></p> <p>A list of events that will enable this diverter. When enabled, the diverter will listen for it's activation and deactivation events</p>"},{"location":"diverter/#disable-events","title":"Disable Events","text":"<p><code>Array</code></p> <p>A list of events that will disable the diverter. Didabled diverters won't react to any activation / deactivation events.</p>"},{"location":"diverter/#optional-settings","title":"Optional Settings","text":""},{"location":"diverter/#activate-events","title":"Activate Events","text":"<p><code>Array</code></p> <p>A list of events that will trigger the action callback with enabled = 1</p>"},{"location":"diverter/#deacctivate-events","title":"Deacctivate Events","text":"<p><code>Array</code></p> <p>A list of events that will trigger the action callback with enabled = 0</p>"},{"location":"diverter/#action-callback","title":"Action Callback","text":"<p><code>String</code></p> <p>The sub or function that is called when the diverter is activated / deactivated.</p>"},{"location":"diverter/#activation-time","title":"Activation Time","text":"<p><code>Number</code></p> <p>The number of seconds after activation the diverter will stay open for</p>"},{"location":"diverter/#activation-switches","title":"Activation Switches","text":"<p><code>Array</code></p> <p>TBC</p>"},{"location":"diverter/#debug","title":"Debug","text":"<p><code>Boolean</code></p>"},{"location":"drop-target/","title":"Drop Target","text":"<p>Drop targets in vpx are implemented via Rothbauerw's DropTarget code. This device extends Roth's Drop Target class to include Knockdown and Reset Events</p>"},{"location":"drop-target/#example","title":"Example","text":"<pre><code>Dim drop1 : Set drop1 = (new DropTarget)(sw04, sw04a, BM_sw04, 4, 0, False, Array(\"ball_started\",\" machine_reset_phase_3\"))\n</code></pre>"},{"location":"event-player/","title":"Event Player","text":"<p>The event player listens for one event and emits one or more other events.</p>"},{"location":"event-player/#example","title":"Example","text":"<pre><code>Dim event_player_super_pops\nSet event_player_super_pops = (New EventPlayer)(\"super_pops\", mode_super_pops)\n\nevent_player_super_pops.Add \"mode_super_pops_started\", _\nArray(_\n\"play_super_pops_start_sound\", _\n\"play_pops_light_show\", _\n\"activate_top_gate _\n\")\n\nevent_player_super_pops.Add \"mode_super_pops_ended\",  _\nArray(_\n\"play_super_pops_end_sound\", _\n\"play_pops_ended_light_show\", _\n\"deactivate_top_gate _\n\")\n</code></pre> <p>In the above example we created a event player called event_player_super_pops that belongs to the mode called mode_super_pops. The event player listens for the mode_super_pops_started event and emits three other events to play a sound, a light show and activate a diverter gate. It also listens for the mode_super_pops_ended event and then emits a end sound, end light show and deactivated the diverter.</p>"},{"location":"event-player/#required-setings","title":"Required Setings","text":""},{"location":"event-player/#name","title":"Name","text":"<p><code>String</code></p> <p>The name of this device. Events emitted from the device will be in the format name_event_player</p>"},{"location":"event-player/#mode","title":"Mode","text":"<p><code>String</code></p> <p>This is the mode the event player belongs to. </p>"},{"location":"events/","title":"Events System","text":"<p>The VPX GLF works on an events based system. All the devices emit and listen to events posted via the commands below</p>"},{"location":"events/#add-pin-event-listener","title":"Add Pin Event Listener","text":"<p>Used to add an event listener. Parameters are:</p> <ul> <li>Event: The event you want to listen to</li> <li>Key: A unqiue key for this event</li> <li>Callback: The function to call when this event fires</li> <li>Priority: The priority the callback should be fired in relation to other callbacks for this event. (Higher priority will be called first)</li> <li>Arguments: Anything to be passed along to the callback function when this event fires.</li> </ul>"},{"location":"events/#example","title":"Example","text":"<pre><code>AddPinEventListener \"sw01_active\", \"switch01Active\", \"HandleSwitchHit\", 1000, Null\n\nSub HandleSwitchHit(args)\n    Dim listenerArgs, dispatchArgs\n    listenerArgs = args(0)\n    dispatchArgs = args(1)\nEnd Sub\n</code></pre> <p>When the event callback is called, a param will be passed along. This is an array where the first item is the args set with AddPinEventListener and the second item is the args sent with the DispatchPinEvent call.</p>"},{"location":"events/#remove-pin-event-listener","title":"Remove Pin Event Listener","text":"<p>Used to remove a pin event listener</p> <pre><code>RemovePinEventListener \"sw01_active\", \"switch01Active\"\n</code></pre>"},{"location":"events/#dispatch-pin-event","title":"Dispatch Pin Event","text":"<p>Used to dispatch a pin event to the system</p> <pre><code>DispatchPinEvent \"sw01_active\", Null\n</code></pre>"},{"location":"events/#dispatch-relay-pin-event","title":"Dispatch Relay Pin Event","text":"<p>Used to dispatch a special pin event to the system where the argument passed with the pin event is relayed and returned to each function.</p> <pre><code>DispatchRelayPinEvent \"sw01_active\", 1\n</code></pre> <p>Listeners to these relay events must return the argument so that the next function can received the updated value</p> <pre><code>Function HandleSwitchHit(args)\n    Dim listenerArgs, dispatchArgs\n    listenerArgs = args(0)\n    dispatchArgs = args(1)\n    dispatchArgs = 2\n    HandleSwitchHit = dispatchArgs\nEnd Function\n</code></pre> <p>In the above example, the initial event dispatched passed 1 as the argument, the HandleSwitchHit received this, changed it to a 2 and returned that value. The next event callback to fire would then recieved the value 2 instead of the initial 1.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#game-logic-devices","title":"Game Logic Devices","text":"<p>A well designed Virtual Pinball table contains many of the real world devices such as scoops, vuks (vertical up kickers), plungers, diverters, drop targets e.t.c. These devices are machine wide devices that need to respond to the ball interacting with them. The classes found in the framework mimic these device behaviours by monitoring and dispatching events which other parts of the system can respond to.</p> <ul> <li>Ball Device</li> <li>Diverters</li> <li>Drop Targets</li> </ul>"},{"location":"features/#game-logic-commands","title":"Game Logic Commands","text":"<p>To program your game, the framework provides a set of classes to manage the game life-cycle, player state, player score, modes, timers, light shows and manage your DMD or LCD game display.</p> <ul> <li>Ball Save</li> <li>Counter</li> <li>Event Player</li> <li>Light Player</li> <li>Mode</li> <li>Multball Locks</li> <li>Multiball</li> <li>Show Player</li> <li>Timer</li> </ul>"},{"location":"installing/","title":"Installation","text":"<p>To install and use the Game Logic Framework in your VPX table, you will need to download the lastest vpx-glf.vbs script and include it in your table script</p> <p>vpx-glf.vbs</p>"},{"location":"installing/#global-script-required-settings","title":"Global Script Required Settings","text":"<p>The GLF requires a few global settings to function correctly. </p>"},{"location":"installing/#glf-event-timer","title":"GLF Event Timer","text":"<p>Add a timer object to your vpx table called Glf_EventTimer. Set it to Enabled with an Interval of 100ms.</p>"},{"location":"installing/#global-script-settings","title":"Global Script Settings","text":"<ul> <li>Your table name must be <code>Table1</code></li> <li><code>cGameName</code> must be set to your table name</li> <li><code>BallSize</code> and <code>BallMass</code> must be set</li> </ul> <p>Example </p> <pre><code>Const cGameName = \"MyAwesomeGame\"\nConst BallSize = 50         'Ball diameter in VPX units; must be 50\nConst BallMass = 1          'Ball mass must be 1\n</code></pre>"},{"location":"installing/#adding-hooks-into-glf","title":"Adding Hooks into GLF","text":"<p>Once the script has been added, you need to add these calls into to your table event subs.</p>"},{"location":"installing/#table-init","title":"Table Init","text":"<p>Inside <code>Table1_Init</code> add <code>Glf_Init()</code></p> <p>Example</p> <pre><code>Sub Table1_Init()\n    Glf_Init()\nEnd Sub\n</code></pre>"},{"location":"installing/#table-exit","title":"Table Exit","text":"<p>Inside <code>Table1_Exit</code> add <code>Glf_Exit()</code></p> <p>Example</p> <pre><code>Sub Table1_Exit()\n    Glf_Exit()\nEnd Sub\n</code></pre>"},{"location":"installing/#table-keys","title":"Table Keys","text":"<p>Inside your <code>Table1_KeyDown</code> and <code>Sub Table1_KeyUp</code> Subs, add the <code>Glf_KeyDown</code> and <code>Glf_KeyUp</code> calls.</p> <p>Example</p> <pre><code>Sub Table1_KeyDown(ByVal keycode)\n    Glf_KeyDown(keycode)\nEnd Sub\n\nSub Table1_KeyUp(ByVal keycode)\n    Glf_KeyUp(keycode)\nEnd Sub\n</code></pre>"},{"location":"installing/#table-options","title":"Table Options","text":"<p>Inside <code>Table1_Options</code> add <code>Glf_Options(eventId)</code></p> <p>Example</p> <pre><code>Sub Table1_OptionEvent(ByVal eventId)\n    If eventId = 1 Then DisableStaticPreRendering = True\n\n    Glf_Options(eventId)\n\n    If eventId = 3 Then DisableStaticPreRendering = False\nEnd Sub\n\n</code></pre>"},{"location":"light-controller/","title":"VPX Light Controller","text":"<p>A class to help vpx original table authors manage light states and custom sequences. Supports managing multiple light states per light, RGB lights, Syncing with VPX light sequences, custom key frame light sequences, import / export of light sequences to show creator and several utility functions for interacting with lights.</p>"},{"location":"light-controller/#installing","title":"Installing","text":"<ul> <li>Download the latest release from github releases and copy the vbs code from lightController.vbs into your vpx table script.</li> </ul>"},{"location":"light-controller/#registering-lights","title":"Registering Lights","text":""},{"location":"light-controller/#vpmmaplights-what-is-it","title":"vpmMapLights - what is it?","text":"<p>-vpmMapLights is a function which is available from the core.vbs script that comes with VPX. It allows you to setup your lights by specifying a light index in the lights timer interval property. This means you could have multiple light objects assigned to the same index to generate a greater light influence, or you might want to tie multiple lights together so they flash at the same time. This technique is used in vpx rom based tables to map the lights to the rom index. We use the same setup here for consistency.</p> <ul> <li>The first thing you need to do is assign a number to each light or    light groups and put that in the light objects timer interval</li> </ul> <p></p> <ul> <li>Next you need to add all of your lights into a vpx collection called aLights</li> </ul> <p></p> <ul> <li>At the top of your table script, make sure these variables are defined:</li> </ul> <pre><code>Const cGameName = \"REPLACE WITH TABLE NAME\"\nDim tablewidth: tablewidth = Table1.width\nDim tableheight: tableheight = Table1.height\n</code></pre> <ul> <li>In your table init sub, you can call the light controller's register lights function</li> </ul> <pre><code>lightCtrl.RegisterLights\n</code></pre> <p>This will do a few things. First, it will call vpmMapLights to setup your light indexes. Next it will build a grid containing all of your light positions, this is used if you want to export your lights and also for some custom color fading routines. Second, it will try to find any lightmaps that might be assoiciated with your lights. (these are primitives you can setup that need to track the opacity and color of your lights). Finally it will create a Sequence Runner for each light, this allows for each light to have multiple states, e.g. a mode shot and a multiball jackpot shot. More on Sequence Runners below.</p> <ul> <li>Finally you need to call <code>lightCtrl.Update()</code> inside a timer. You can reuse an existing timer or setup a new one. A 16ms timer works well</li> </ul>"},{"location":"light-controller/#light-controller-features","title":"Light Controller Features","text":"<ul> <li>Managing Lights<ul> <li>Light On/Off</li> <li>Light Blink</li> <li>Light Color</li> <li>Light Level</li> <li>Light Utilities<ul> <li>Light On With Color</li> <li>Light On With Flicker</li> <li>Light Pulse</li> <li>Light Pulse With Profile</li> </ul> </li> </ul> </li> <li>Managing Shots<ul> <li>Add Shot</li> <li>Remove Shot</li> <li>Remove All Shots</li> <li>Is Shot Lit</li> </ul> </li> <li>Syncing With VPX Lights</li> <li>Light Sequences<ul> <li>VPX Sequences</li> <li>Custom Sequences</li> <li>MPF Show Creator</li> <li>Exporting Lights</li> <li>Importing Light Shows</li> </ul> </li> </ul>"},{"location":"light-controller/#managing-lights","title":"Managing Lights","text":"<p>To control your lights you can call the following functions on the light controller object. All these require you to pass the vpx light as a parameter. E.g. The below examples assume you have a light in vpx called L01</p>"},{"location":"light-controller/#light-onoffblink","title":"Light On/Off/Blink","text":"<p>To turn a light on you use: LightOn and LightOff. To  set a light on a repeating Blink, you can use Blink</p> <pre><code>lightCtrl.LightOn L01\nlightCtrl.LightOff L01\nlightCtrl.Blink L01\n</code></pre> <p></p> <p></p>"},{"location":"light-controller/#light-color","title":"Light Color","text":"<p>VPX lights have color and fullColor properties. To change the light color use: LightColor</p> <pre><code>lightCtrl.LightColor L01, RGB(255,0,0) 'Sets the color property to Red\n\nlightCtrl.LightColor L01, Array(RGB(255,0,0), Null) 'Sets the color to Red\n\nlightCtrl.LightColor L01, Array(RGB(255,0,0), RGB(0,255,0)) 'Sets the color and fullColor propteries to Red &amp; Green\n\nlightCtrl.LightColor L01, Array(Null, RGB(0,0,255)) 'Sets the fullColor to Blue\n</code></pre> <p></p>"},{"location":"light-controller/#light-level","title":"Light Level","text":"<p>All of the lights registerd with the controller will be set to modulate brightness between 0-100. To change the level use: LightLevel</p> <pre><code>lightCtrl.LightLevel L01, 50 'Set the lights maximum brightness to 50%\n\nlightCtrl.LightLevel L01, 100 'Set the lights maximum brightness to 100%\n</code></pre> <p></p>"},{"location":"light-controller/#light-utilities","title":"Light Utilities","text":"<p>To help control common light events there are some utility functions available:</p>"},{"location":"light-controller/#light-on-with-color","title":"Light On With Color","text":"<p>Turns a light whilst also setting the color</p> <pre><code>lightCtrl.OnWithColor L01, RGB(255,0,0)\n</code></pre>"},{"location":"light-controller/#fade-light-to-color","title":"Fade Light To Color","text":"<p>Changes the color of a light to a new color, with a fading effect over a specified duration. </p> <p><code>lightCtrl.FadeLightToColor L01, RGB(255,0,0), 180</code></p>"},{"location":"light-controller/#light-on-with-flicker","title":"Light On With Flicker","text":"<p>Turns a light on with a short flickering sequence</p> <pre><code>lightCtrl.OnWithFlicker L01\n</code></pre> <p></p>"},{"location":"light-controller/#light-pulse","title":"Light Pulse","text":"<p>Pulses a light with the default pulse sequence. The state of the light does not change. E.g. after the pulse has finished, if the light was previously on, it will be on again.</p> <p>The second parameter is the number of times to repeat the pulse.</p> <pre><code>lightCtrl.Pulse L01, 0 'Pulse the light once, no repeat (total 1 pulse)\n\nlightCtrl.Pulse L01, 1 'Pulse the light, repeat the pulse once (total 2 pulses)\n</code></pre> <p></p>"},{"location":"light-controller/#light-pulse-with-profile","title":"Light Pulse With Profile","text":"<p>Pulses a light with a custom pulse sequence. The state of the light does not change. E.g. after the pulse has finished, if the light was previously on, it will be on again.</p> <p>The second parameter is the pulse sequence to use. Each element in the array is the brightness of the light for that frame. Each frame is 20ms so the 5 element seq below would last 100ms.</p> <pre><code>lightCtrl.PulseWithProfile L01, Array(10,50,100,50,0), 0\n</code></pre>"},{"location":"light-controller/#light-pulse-with-color","title":"Light Pulse With Color","text":"<p>Pulses a light with a color. The state of the light does not change. E.g. after the pulse has finished, if the light was previously on, it will be on again and the color will reset.</p> <pre><code>lightCtrl.PulseWithColor L01, RGB(255,0,0), 0\n</code></pre>"},{"location":"light-controller/#managing-shots","title":"Managing Shots","text":"<p>Aside from turning lights on and making them blink, you can add dfferent sequences to lights which run one after the other. You can manually manage this by creating sequence runners and adding / removing sequences. For convience the most common senarnio is to have one light lit for lots of differnt reasons. You may have a light lit for a mode shot but also for a jackpot or combo. The light controller lets you add multiple \"Shots\" to a light.</p>"},{"location":"light-controller/#add-shot","title":"Add Shot","text":"<p>To add a new shot to a light use: AddShot</p> <pre><code>lightCtrl.AddShot \"Name\", L01, RGB(255,0,0)\n</code></pre> <p>The first parameter is a name for the shot so we can reference it later. The second parameter is the vpx light object The third parameter is the color you want this shot to be.</p> <p></p>"},{"location":"light-controller/#remove-shot","title":"Remove Shot","text":"<p>To remove a shot from a light use: RemoveShot</p> <pre><code>lightCtrl.RemoveShot \"Name\"\n</code></pre> <p>Call remove shot with the name of the shot you want to remove</p>"},{"location":"light-controller/#remove-all-shots","title":"Remove All Shots","text":"<p>To remove all shots from a light use: RemoveAllShots</p> <pre><code>lightCtrl.RemoveAllShots L01\n</code></pre> <p>Call remove all shots with the vpx light object</p>"},{"location":"light-controller/#is-shot-lit","title":"Is Shot Lit","text":"<p>To check if a shot is current active on the light use: IsShotLit</p> <pre><code>lightCtrl.IsShotLit \"Name\", L01\n</code></pre> <p>The first parameter is the name of the shot The second parameter is the vpx light object</p>"},{"location":"light-controller/#light-sequences","title":"Light Sequences","text":""},{"location":"light-controller/#vpx-sequences","title":"VPX Sequences","text":"<p>The light controller can sync your lights to VPX light sequences</p> <p>In the example below you start the vpx sequence SeqCircleOutOn. Then call the light controller SyncWithVpxLights function with the collection the vpx light sequence uses. This will start syncing your lights.</p> <pre><code>SomeVPXLightSeq.Play SeqCircleOutOn,50,100\nlightCtrl.SyncWithVpxLights SomeVPXLightSeq\n\n'Stop syncing with vpx lights once the sequence is complete\nSub SomeVPXLightSeq_PlayDone()\n    lightCtrl.StopSyncWithVpxLights()\nEnd Sub\n</code></pre> <p>By default this will use the current color of the light. If you want to override the color of all the lights during the sequence you can use SetVpxSyncLightColor</p> <pre><code>SomeVPXLightSeq.Play SeqCircleOutOn,50,100\nlightCtrl.SyncWithVpxLights VpxCollection\nlightCtrl.SetVpxSyncLightColor RGB(255,0,0)\n</code></pre>"},{"location":"light-controller/#custom-sequences","title":"Custom Sequences","text":"<p>The controller supports writing your own custom sequences using a SequenceRunner and LightSequence items. Each Sequence Runner added to the controller is ran concurrently with other sequence runners. Each Light Sequence added to a runner is ran one after the other (following).</p> <p>Lets say you have a set of 3 lights and you want to light one after the other on repeat.</p> <p></p> <p>The sequence might this:</p> <ul> <li>First frame: </li> <li>Light 1 On</li> <li>Second frame:</li> <li>Light 1 Off</li> <li>Light 2 On</li> <li>Third Frame:</li> <li>Light 2 Off</li> <li>Light 3 Off</li> <li>Fourth Frame: </li> <li>Light 3 Off</li> </ul> <p>Using the controller you can create a sequence runner for this using CreateSeqRunner</p> <pre><code>lightCtrl.CreateSeqRunner \"_RunnerName_\" 'Runner name can be anything you want\n</code></pre> <p>Then you need to create the actual sequence using the LCSeq class.</p> <pre><code>Dim lSeqTest: Set lSeqTest = new LCSeq\nlSeqTest.Name = \"lSeqTest\"\n\nlSeqTest.Sequence = Array( _\n                    Array(\"L01|100\"), _\n                    Array(\"L01|0\", \"L02|100\"), _\n                    Array(\"L02|0\", \"L03|100\"), _\n                    Array(\"L03|0\"))\n\nlSeqTest.UpdateInterval = 180\nlSeqTest.Color = Null\nlSeqTest.Repeat = True\n\n</code></pre> <p>Finally, when you want to run the sequence, you need to add it to the runner you created using AddLightSeq.</p> <pre><code>lightCtrl.AddLightSeq \"_RunnerName_\", lSeqTest\n</code></pre> <p>As the above example is set to repeat, you can stop it by using RemoveLightSeq</p> <pre><code>lightCtrl.RemoveLightSeq \"_RunnerName_\", lSeqTest\n</code></pre>"},{"location":"light-controller/#color-palettes","title":"Color Palettes","text":"<p>When runnning light sequences it's nice to be able to change the color of the sequence. In addition to the color and sync color properties, the Light Controller supports palettes of color (gradients). </p> <p>To create a palette there are two options. You can create a palette between a start and end color, this will be a gradient from start to finish. Or you can create a palette with multiple color stops. </p> <p>To create a simple start and end palette you use:</p> <pre><code>Dim palette\npalette = lightCtrl.CreateColorPalette(\"FF0000\", \"0000FF\")\n</code></pre> <p></p> <p>The colors are defined with a hex value (above, red -&gt; blue).</p> <p>To create a palette with stops you can use:</p> <p><code>lightCtrl.CreateColorPaletteWithStops(\"FF0000\", \"0000FF\", Array(127), Array(\"00FF00\"))</code></p> <p></p> <p>Here we need to pass in the start and end colors with an array of stop posistions and an array of stop colors for those positions. Note the palette is 255 colors, so the above creates a green stop at position 127 (50%).</p>"},{"location":"light-controller/#how-palette-are-applied-to-sequences","title":"How palette are applied to sequences","text":"<p>You can use palettes with either any custom sequence or when syncing lights with vpx sequences.</p> <ul> <li> <p>Palette with VPX Seq</p> <ul> <li> <p><code>lightCtrl.SetVpxSyncLightsPalette paletteWithStops, \"LeftToRight\", 0</code></p> <ul> <li>param1: the palette</li> <li>param2: direction</li> <li>param3: speed<ul> <li>The direction param determines how the palette is applied to the lights. The options available are:</li> </ul> </li> <li>TopToBottom</li> <li>BottomToTop</li> <li>LeftToRight</li> <li>RightToLeft</li> <li>RadialOut</li> <li>RadialIn</li> <li>Clockwise</li> <li>AntiClockwise</li> </ul> </li> <li> <p>The speed param allows you to shift the colors in the palette over time. </p> <ul> <li>A value of 0 or Null wont shift the colors at all during the sequence</li> <li>Any other value e.g. 120 will shift the colors by 1 every 120ms.</li> </ul> </li> </ul> </li> <li> <p>Palette with Sequence Runner</p> <ul> <li><code>lSeqTest.Palette = Array(paletteWithStops, \"LeftToRight\", 0)</code><ul> <li>Same params as above however this time they are assigned as an array    to the palette property of the sequence runner</li> </ul> </li> </ul> </li> </ul>"},{"location":"light-controller/#show-creator","title":"Show Creator","text":"<p>For more complex light sequences the controller supports exporting your table lights so that they can be imported a tool called showcreator</p> <p>https://github.com/missionpinball/showcreator</p> <p></p> <p></p> <p>Show Creator is a tool for creating lightshows in MPF (Mission Pinball Framework). It takes a YAML file which describes your light locations and exports a YAML file with key frame data of the light show you created.</p> <p>We can use some functions on the light controller to help us integrate with MPF Show Creator</p>"},{"location":"light-controller/#exporting-lights","title":"Exporting Lights","text":"<p>You can export the position of your lights by using CompileLights. You need to pass in a vpx collection of the lights you want to export (this lets you have more fine grain control over which lights to animate in show creator).</p> <p>To export lights you need to have the variable cGameName set in your table. This is used to export the file to your computer in a subfolder called cGameName_LightShows</p> <pre><code>lightCtrl.CompileLights _VPXCollection_, \"filename\"\n</code></pre> <p>This will export a file you can use in MPF Show Creator.</p>"},{"location":"light-controller/#importing-light-shows","title":"Importing Light Shows","text":"<p>You can import the created lights into your table with the LoadLightShows command. This will read light show files saved from Show Creator and compile them to light sequences the controller can run. LoadLightShows will also output a file called lights-out.txt which contains the compiled vbs code for the light sequence. For development is easier to call LoadLightShows, however you should copy the compiled lightshows into your tablescript before sharing it.</p> <pre><code>lightCtrl.LoadLightShows\n</code></pre>"},{"location":"light-player/","title":"Light Player","text":"<p>The light player </p>"},{"location":"light-player/#example","title":"Example","text":""},{"location":"light-player/#required-setings","title":"Required Setings","text":""},{"location":"light-player/#name","title":"Name","text":"<p><code>String</code></p> <p>The name of this device. Events emitted from the device will be in the format name_event_player</p>"},{"location":"light-player/#mode","title":"Mode","text":"<p><code>String</code></p> <p>This is the mode the event player belongs to. </p>"},{"location":"mode/","title":"Mode","text":"<p>All of the game logic commands need to be a member of a mode.</p>"},{"location":"mode/#example","title":"Example","text":"<pre><code>Dim mode_super_pops\nSet mode_super_pops = (new Mode)(\"super_pops\", 2000)\n\nWith mode_super_pops\n    .StartEvents = Array(\"ball_started\")\n    .StopEvents = Array(\"ball_ended\")\nEnd With\n</code></pre> <p>In the example, we created a super pops mode with a priorty of 2000. The mode will start when the ball_started event emits and it will end when the ball_ended event emits. This mode by it self doesn't do much, you need to define other commands for this mode like counters, timers, shots e.t.c. All commands added to this mode will run at the same priority level.</p>"},{"location":"multiball-locks/","title":"Multiball Locks","text":"<p>This command tracks balls locked for a multiball. It is used with the multiball command to start multiballs.</p>"},{"location":"multiball-locks/#example","title":"Example","text":"<pre><code>Dim waterfall_mb_locks\nSet waterfall_mb_locks = (new MultiballLocks)(\"waterfall\", mode_waterfall_mb) \n\nWith waterfall_mb_locks\n    .EnableEvents = Array(\"enable_waterfall\")\n    .DisableEvents = Array(\"disable_waterfall\")\n    .BallsToLock = 3\n    .LockEvents = Array(\"balldevice_bd_waterfall_vuk_ball_eject_success\")\n    .ResetEvents = Array(\"multiball_waterfall_started\")\nEnd With\n</code></pre> <p>In the above example we defined a multiball lock for the waterfall multiball. This is a three ball multiball. When the lock is enabled and the ball device waterfall_vuk successfully ejects a ball, it will count that ball as locked. This could be a physical table locked ball, or a virutal locked ball.</p>"},{"location":"multiball/","title":"Multiball","text":""},{"location":"multiball/#example","title":"Example","text":"<pre><code>Dim waterfall_mb\nSet waterfall_mb = (new Multiball)(\"waterfall\", \"multiball_locks_waterfull\" ,mode_waterfall_mb)\n\nWith waterfall_mb\n    .EnableEvents = Array(\"mode_waterfall_mb_started\")\n    .DisableEvents = Array(\"mode_waterfall_mb_ended\")\n    .StartEvents = Array(\"multiball_locks_waterfall_full\")\nEnd With\n</code></pre> <p>See multiball locks for how to count locked multiballs. In this example we create a waterfall multiball, the multiball will start when the multiball locks emits that it is full.</p>"},{"location":"player-state/","title":"Player State","text":"<p>The player state stores variables per player. </p>"},{"location":"player-state/#set-player-state","title":"Set Player State","text":"<p><code>SetPlayerState</code> is used to put data into the player state. You need a key and value.</p> <pre><code>SetPlayerState \"current_ball\", 1\n</code></pre>"},{"location":"player-state/#get-player-state","title":"Get Player State","text":"<p><code>GetPlayerState</code> is used to get data out of the player state.</p> <pre><code>GetPlayerState \"current_ball\"\n</code></pre>"},{"location":"player-state/#player-events","title":"Player Events","text":"<p>When a player state value changes it will post an event so you can respond to that change. e.g. light changes, dmd updates.</p>"},{"location":"player-state/#add-player-state-event-listener","title":"Add Player State Event Listener","text":"<p>To start monitoring a player event.</p> <p>The parameters are: </p> <ul> <li>Player State Key: e.g. \"score\", this is the value you want to monitor</li> <li>Key: A unqiue key for this listnener. You can have multiple subs monitoring the same value doing different things. This key is used to separate those.</li> <li>Callback: The Sub or Function to call when the value changes</li> <li>Priority: callbacks will be called in priority order, the higher priorities will be called first.</li> <li>Args: Any arguments you want to pass along to the callback.</li> </ul> <pre><code>AddPlayerStateEventListener \"score\", \"player_score_changed\", \"UpdateDMD\", 1000, Null\n</code></pre>"},{"location":"player-state/#remove-player-state-event-listener","title":"Remove Player State Event Listener","text":"<p>To stop monitoring a player event.</p> <pre><code>RemovePlayerStateEventListener \"score\", \"player_score_change\"\n</code></pre>"},{"location":"timer/","title":"Timer","text":"<p>Timers manage event durations, triggering multiball modes, bonus rounds, and target resets.</p>"},{"location":"timer/#example","title":"Example","text":"<pre><code>Dim timer_beasts_panther\nSet timer_beasts_panther = (new ModeTimer)(\"beasts_panther\", mode_beasts)\n\nWith timer_beasts_panther\n    .StartEvents = Array(\"sw01_active\")\n    .StopEvents = Array(\"sw01_inactive\")\n    .Direction = \"down\"\n    .StartValue = 10\n    .EndValue = 0\nEnd With\n</code></pre>"},{"location":"timer/#events","title":"Events","text":"<p><code>timer_*name*_started</code></p> <p><code>timer_*name*_stopped</code></p> <p><code>timer_*name*_complete</code></p> <p><code>timer_*name*_tick</code></p>"}]}